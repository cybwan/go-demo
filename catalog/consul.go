package catalog

import (
	"strings"

	"github.com/hashicorp/consul/api"
)

var (
	consulDiscoveryClient *ConsulDiscoveryClient
)

type ConsulDiscoveryClient struct {
	consulClient *api.Client
}

func (dc *ConsulDiscoveryClient) CatalogServices(q *QueryOptions) (map[string][]string, error) {
	servicesMap, meta, err := dc.consulClient.Catalog().Services(q.toConsul())
	if err != nil {
		return nil, err
	}

	q.WaitIndex = meta.LastIndex

	catalogServices := make(map[string][]string)
	if len(servicesMap) > 0 {
		for svc, svcTags := range servicesMap {
			if strings.EqualFold(svc, "consul") {
				continue
			}
			for _, svcTag := range svcTags {
				tags := parseTags(svcTag)
				svcTagArray, exists := catalogServices[svc]
				if !exists {
					svcTagArray = make([]string, 0)
				}
				svcTagArray = append(svcTagArray, tags...)
				catalogServices[svc] = svcTagArray
			}
		}
	}
	return catalogServices, nil
}

// CatalogService is used to query catalog entries for a given service
func (dc *ConsulDiscoveryClient) CatalogService(service, tag string, q *QueryOptions) ([]*CatalogService, error) {
	// Only consider services that are tagged from k8s
	services, _, err := dc.consulClient.Catalog().Service(service, tag, q.toConsul())
	if err != nil {
		return nil, err
	}

	catalogServices := make([]*CatalogService, len(services))
	for idx, svc := range services {
		catalogServices[idx] = new(CatalogService)
		catalogServices[idx].fromConsul(svc)
	}
	return catalogServices, nil
}

// HealthService is used to query catalog entries for a given service
func (dc *ConsulDiscoveryClient) HealthService(service, tag string, q *QueryOptions, passingOnly bool) ([]*AgentService, error) {
	services, _, err := dc.consulClient.Health().Service(service, tag, passingOnly, q.toConsul())
	if err != nil {
		return nil, err
	}

	agentServices := make([]*AgentService, len(services))
	for idx, svc := range services {
		agentServices[idx] = new(AgentService)
		agentServices[idx].fromConsul(svc.Service)
	}
	return agentServices, nil
}

func (dc *ConsulDiscoveryClient) NodeServiceList(node string, q *QueryOptions) (*CatalogNodeServiceList, error) {
	nodeServices, meta, err := dc.consulClient.Catalog().NodeServiceList(node, q.toConsul())
	if err != nil {
		return nil, err
	}

	// Update our blocking index
	q.WaitIndex = meta.LastIndex

	nodeServiceList := new(CatalogNodeServiceList)
	nodeServiceList.fromConsul(nodeServices)
	return nodeServiceList, nil
}

func (dc *ConsulDiscoveryClient) Deregister(dereg *CatalogDeregistration) error {
	_, err := dc.consulClient.Catalog().Deregister(dereg.toConsul(), nil)
	return err
}

func (dc *ConsulDiscoveryClient) Register(reg *CatalogRegistration) error {
	_, err := dc.consulClient.Catalog().Register(reg.toConsul(), nil)
	return err
}

const (
	WildcardNamespace = "*"
	DefaultNamespace  = "default"
)

// EnsureNamespaceExists ensures a Consul namespace with name ns exists. If it doesn't,
// it will create it and set crossNSACLPolicy as a policy default.
// Boolean return value indicates if the namespace was created by this call.
func (dc *ConsulDiscoveryClient) EnsureNamespaceExists(ns string, crossNSAClPolicy string) (bool, error) {
	if ns == WildcardNamespace || ns == DefaultNamespace {
		return false, nil
	}
	// Check if the Consul namespace exists.
	namespaceInfo, _, err := dc.consulClient.Namespaces().Read(ns, nil)
	if err != nil {
		return false, err
	}
	if namespaceInfo != nil {
		return false, nil
	}

	// If not, create it.
	var aclConfig api.NamespaceACLConfig
	if crossNSAClPolicy != "" {
		// Create the ACLs config for the cross-Consul-namespace
		// default policy that needs to be attached
		aclConfig = api.NamespaceACLConfig{
			PolicyDefaults: []api.ACLLink{
				{Name: crossNSAClPolicy},
			},
		}
	}

	consulNamespace := api.Namespace{
		Name:        ns,
		Description: "Auto-generated by consul-k8s",
		ACLs:        &aclConfig,
		Meta:        map[string]string{"external-source": "kubernetes"},
	}

	_, _, err = dc.consulClient.Namespaces().Create(&consulNamespace, nil)
	return true, err
}

func ParseTag(tag string) (k, v string) {
	segs := strings.Split(tag, "=")
	if len(segs) > 0 {
		k = segs[0]
	}
	if len(segs) > 1 {
		v = segs[1]
	}
	return
}

func GetConsulDiscoveryClient() *ConsulDiscoveryClient {
	if consulDiscoveryClient == nil {
		consulDiscoveryClient = new(ConsulDiscoveryClient)
		c := api.DefaultConfig()
		c.Address = "127.0.0.1:8500"
		consulDiscoveryClient.consulClient, _ = api.NewClient(c)
	}
	return consulDiscoveryClient
}
